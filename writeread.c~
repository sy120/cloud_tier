#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <math.h>
#include <fcntl.h>
#include <string.h>
#include <unistd.h>
//#include <libexplain/pwrite.h>
#define BLOCK_SIZE 4096
#define SIZE 1


int my_write(char* buf, size_t size, off_t offset) {

  size_t offset_within_block = (size_t)(offset % BLOCK_SIZE);
  size_t block_number = (size_t) (offset / BLOCK_SIZE);
  printf("offset is %zd\n", offset_within_block);
  printf("block_number is %zd\n", block_number);

  //  int len = (int)BLOCK_SIZE;
 
  char readpath[256] = "/home/bitnami/demo/hello";//这里需要改！change this path string to be ex./home/bitnami/demo/hello
  printf("The write path is %s\n", readpath);
    //    sprintf(readpath, "/home/bitnami/files/20");
    //logging(readpath, "write readpath = ");
  //FILE* fd = fopen(readpath,"w+");
  sprintf(readpath, "/home/bitnami/demo/hello");
  int fd = open(readpath, O_RDWR, S_IRUSR | S_IWUSR);
  //if (fd == NULL) {
  //  printf("file open error!\n");
  //  return -1;
  //}
  //fseek(fd, offset_within_block, SEEK_SET);
  //fwrite(buf, size+1, SIZE, fd);
  printf("write fd is %d\n", fd);
  printf("write offset is %zd\n", offset);
  printf("write size is %zd\n", size);
  printf("The write buffer is %s\n", buf);
  ssize_t res = pwrite(fd, buf, size, offset);
  if (res >= 0) printf("small write success!\n");
  else {
    int err = errno;
    printf("small write errno = %d!\n", err);
    printf("error number is %zd\n", res);
    //fprintf(stderr, "%s\n", explain_errno_pwrite(res, fd, buf, size, offset));   	
  }
  close(fd);
  return size;
}

int my_read(char* buf, size_t size, off_t offset) {
  printf("read offset is %zd\n", offset);
  printf("read size is %zd\n", size);

  // size_t offset_within_block = (size_t)(offset % BLOCK_SIZE);
  // size_t block_number = (size_t) (offset / BLOCK_SIZE);

  //int len = BLOCK_SIZE;
  char readpath[256] = "/home/bitnami/demo/hello";//这里也一样！ex./home/bitnami/demo/hello
  printf("The read path is %s\n", readpath);
  sprintf(readpath, "/home/bitnami/demo/hello");
  int fd = open(readpath, O_RDWR, S_IRUSR | S_IWUSR);
  printf("read fd is %d\n", fd);
  printf("read offset is %zd\n", offset);
  printf("read size is %zd\n", size);
  //printf("The read buffer is %s\n", buf);
  ssize_t res = pread(fd, buf, size, offset);
  if (res >= 0) {
    printf("small read success!\n");
    printf("The read buffer is %s\n", buf);
  }
  else {
    int err = errno;
    printf("small read errno = %d!\n", err);
    printf("error number is %zd\n", res);
  }
  close(fd);	
  //printf("The read output is %s\n", buf);
  //printf("small read success!\n");
  return size;
}

int main(int argc, char* argv[]) {
  if (argc < 2) {
    printf("type read or write!\n");
    return 1;
  }
  off_t offset = 0;
  char buf[256] = {'\0'};
  //size_t size = 0;
  char output[256] = {'\0'};
  if (strcmp("write", argv[1]) == 0) {
    printf("type content and offset!\n");
    strcat(buf, argv[2]);
    printf("The buf contains %s\n", buf);
    offset = atoi(argv[3]);
    my_write(argv[2], strlen(argv[2]), offset);
  } else { 
    //read(output, size, offset);
    //printf("read result is %s\n", output);
    printf("type read size and offset!\n");
    size_t read_size = atoi(argv[2]);
    printf("The buf contains %s\n", buf);
    off_t offset = atoi(argv[3]);
    my_read(output, read_size, offset);	
  }
  return 1;
}


